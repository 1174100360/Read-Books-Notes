# 08.控制对象的访问

- 使用 getter 和 setter 控制访问对象的属性
- 通过代理控制对象的访问
- 使用代理解决交叉访问的问题

## 使用 getter 与 setter 控制属性访问

```js
function Ninja(level) {
  this.skillLevel = level;
}
const ninja = new Ninja(100);
```

定义了构造函数 Ninja，使用该构造函数创建实例 ninja，它仅具有一个属 性 `skillLevel`。然后，如果我们想要改变属性 `skillLevel`，我们可以通过代码实现: `ninja.skillLevel = 20`。

- 我们需要避免意外的错误发生，例如错误赋值。举例来说，需要避免赋了错误 类型的值: `ninja.skillLevel = "high"`。
- 我们需要记录 `skillLevel` 属性的变化。
- 我们需要在网页的 UI 中显示 `skillLevel` 属性的值。我们自然需要显示 `skillLevel` 属性的更新值，但是如何轻松地做到这一点呢?

通过 `getter` 和 `setter` 方法，我们可以很优雅地实现这一切。

**使用 getter 和 setter 保护私有属性**

```js
function Ninja() {
  let skillLevel;
  this.getSkillLevel = () => skillLevel;
  this.setSkillLevel = value => {
    skillLevel = value;
  };
}
const ninja = new Ninja();
ninja.setSkillLevel(100);
console.log(ninja.getSkillLevel() === 100);
```

### 定义 getter 和 setter

在 JavaScript 中，可以通过两种方式定义 getter 和 setter。

- 通过对象字面量定义，或在 ES6 的 class 中定义。
- 通过使用内置的 Object.defineProperty 方法。

**在对象字面量中定义 getter 和 setter**

```js
const ninjaCollection = {
  ninjas: ['Yoshi', 'Kuma', 'Hattori'],
  get firstNinja() {
    report('Getting firstNinja');
    return this.ninjas[0];
  },
  set firstNinja(value) {
    report('Setting firstNinja');
    this.ninjas[0] = value;
  }
};
console.log(ninjaCollection.firstNinja === 'Yoshi');
ninjaCollection.firstNinja = 'Hachi';
console.log(
  ninjaCollection.firstNinja === 'Hachi' &&
    ninjaCollection.ninjas[0] === 'Hachi'
);
```

**在 ES6 的 class 中使用 getter 和 setter**

```js
class NinjaCollection {
  constructor() {
    this.ninjas = ['Yoshi', 'Kuma', 'Hattori'];
  }
  get firstNinja() {
    report('Getting firstNinja');
    return this.ninjas[0];
  }
  set firstNinja(value) {
    report('Setting firstNinja');
    this.ninjas[0] = value;
  }
}
const ninjaCollection = new NinjaCollection();
```

> 针对指定的属性不一定需要同时定义 getter 和 setter。例如，通常我们仅提供 getter。如果在某些情况下需要写入属性值，具体的行为取决于代码是在严格模式还是非严格模式。如果在非严格模式下，对仅有 getter 的属性赋值不起作用，JavaScript 引擎默默地忽略我们的请求。另一方面，如果在严格模式下，JavaScript 引擎将会抛出异常，表明我们试图将给一个仅有 getter 没有 setter 的属性赋值。

**Object.defineProperty**

```js
function Ninja() {
  let _skillLevel = 0;
  Object.defineProperty(this, 'skillLevel', {
    get: () => {
      console.log('The get method is called');
      return _skillLevel;
    },
    set: value => {
      console.log('The set method is called');
      _skillLevel = value;
    }
  });
}
const ninja = new Ninja();
console.log(typeof ninja._skillLevel === 'undefined');
console.log(ninja.skillLevel === 0);
ninja.skillLevel = 10;
console.log(ninja.skillLevel === 10);
```

### 使用 getter 与 setter 校验属性值

```js
function Ninja() {
  let _skillLevel = 0;
  Object.defineProperty(this, 'skillLevel', {
    get: () => _skillLevel,
    set: value => {
      if (!Number.isInteger(value)) {
        throw new TypeError('Skill level should be a number');
      }
      _skillLevel = value;
    }
  });
}
const ninja = new Ninja();
ninja.skillLevel = 10;
console.log(ninja.skillLevel === 10);

try {
  ninja.skillLevel = 'Great';
  console.log('Should not be here');
} catch (e) {
  console.log('Setting a non-integer value throws an exception');
}
```

### 使用 getter 与 setter 定义如何计算属性值

```js
const shogun = {
  name: 'Yoshiaki',
  clan: 'Ashikaga',
  get fullTitle() {
    return this.name + ' ' + this.clan;
  },
  set fullTitle(value) {
    const segments = value.split(' ');
    this.name = segments[0];
    this.clan = segments[1];
  }
};
console.log(shogun.name === 'Yoshiaki');
console.log(shogun.clan === 'Ashikaga');
console.log(shogun.fullTitle === 'Yoshiaki Ashikaga');
shogun.fullTitle = 'Ieyasu Tokugawa';
console.log(shogun.name === 'Ieyasu');
console.log(shogun.clan === 'Tokugawa');
console.log(shogun.fullTitle === 'Ieyasu Tokugawa');
```

## 使用代理控制访问

可以将代理 理解为通用化的 setter 与 getter，区别是每个 setter 与 getter 仅能控制单个对象属性，而代理可用于对象交互的通用处理，包括调用对象的方法。

**通过 Proxy 构造器创建代理**

```js
const emperor = { name: 'Komei' };
const representative = new Proxy(emperor, {
  get: (target, key) => {
    console.log('Reading ' + key + ' through a proxy');
    return key in target ? target[key] : "Don't bother the emperor!";
  },
  set: (target, key, value) => {
    console.log('Writing ' + key + ' through a proxy');
    target[key] = value;
  }
});
console.log(emperor.name === 'Komei');
console.log(representative.name === 'Komei');
console.log(emperor.nickname === undefined);
console.log(representative.nickname === "Don't bother the emperor!");
representative.nickname = 'Tenno';
console.log(emperor.nickname === 'Tenno');
console.log(representative.nickname === 'Tenno');
```
